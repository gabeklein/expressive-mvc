import { Tabs, Tab, Steps } from 'nextra-theme-docs';

import Link from 'next/link'
import CounterExample from 'example/Counter';

## Starting from scratch

Expressive MVC is architected to be as simple as possible, and needs little to no setup.
`Model` handles reactivity "under the hook" to accomplish most tasks.
It's designed to be extended with your own state and logic, so any opinions are your own.

<Steps>
  ### Install `@expressive/react`

  <Tabs items={['npm', 'yarn', 'pnpm']} storageKey="selected-pkg-manager">
    <Tab>
      ```bash copy
      npm i @expressive/react
      ```
    </Tab>
    <Tab>
      ```bash copy
      yarn add @expressive/react
      ```
    </Tab>
    <Tab>
      ```bash copy
      pnpm install @expressive/react
      ```
    </Tab>
  </Tabs>

  ### Import and extend `Model`

  Define any values you wish to track within a given component.

  ```js
    import Model from "@expressive/react";

    class Counter extends Model {
      current = 1

      increment = () => { this.current += 1 };
      decrement = () => { this.current -= 1 };
    }
  ```

  > Here we'll also define some methods. This isolates the logic for incrementing
  > and decrementing the counter, so it doesn't need to live in the component.

  ### Use model as a hook

 Static method `use()` (inherited from `Model`) is hook which will create,
  memoize and subscribe to all state used by this component.

  ```jsx
    function MyCounter(){
      const { current, increment, decrement } = Counter.use();

      return (
        <div>
          <button onClick={decrement}>{"-"}</button>
          <pre>{current}</pre>
          <button onClick={increment}>{"+"}</button>
        </div>
      )
    }
  ```

  ### Place it in your app

  <CounterExample />

  Done already? Apparently we have something usable. ðŸš€ <br />
  [View in codesandbox](https://codesandbox.io/s/example-counter-th8xl)
</Steps>

## Migrating `useState`

`useState` is pretty straightforward as hooks go, but it does not scale well.
Often there's repetition and not *immediately* clear what is intended behavior.
Lot of closures get created too, which hurts performance if the component renders often.

```js
  function Component(){
    const [foo, setFoo] = useState(0);
    const [bar, setBar] = useState(0);
    const [baz, setBaz] = useState(0);

    return (
      <div>
        <button onClick={() => setFoo(x => x+1)}>Foo is {foo}</button>
        <button onClick={() => setBar(x => x+1)}>Bar is {bar}</button>
        <button onClick={() => setBaz(x => x+1)}>Baz is {baz}</button>
      </div>
    )
  }
```

First combine `foo`, `bar` and `baz` into a single hook using Model.
The built-in [`is` property](/model/is) will help with assignment.
It's added to any observable (model) when accessed by a subscriber
(component). Just a reference to the original instance, it allows for
assignment after destructuring.

```js {8, 12-14}
  class Control extends Model {
    foo = 0;
    bar = 0;
    baz = 0;
  }

  function Component(){
    const { is: control, foo, bar, baz } = Control.use();

    return (
      <div>
        <button onClick={() => control.foo++}>Foo is {foo}</button>
        <button onClick={() => control.bar++}>Bar is {bar}</button>
        <button onClick={() => control.baz++}>Baz is {baz}</button>
      </div>
    )
  }
```

> Because we're assigning directly to `control`, the values will always be
> up-to-date; we never need to worry about dispatch functions or stale closures.

## Migrating `useCallback`

The often overlooked `useCallback` hook is a great way to avoid unnecessary renders caused by new closures.

## Migrating `useEffect`

TBD

