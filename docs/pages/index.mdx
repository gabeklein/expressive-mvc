## Overview

Expressive MVC is state-management for React, built around javascript classes.
It's an ergonomic alternative to reducer-style managers like [Redux](https://redux.js.org), and is inspired in-part by [MobX](https://mobx.js.org/README.html).
It comes with built-in support for Context, Suspense, and React Hooks.

Expressive works primarily through it's default export [`Model`](/apis/model), an (almost) empty class to be extended by you.
A custom model can contain any number of properties, methods, and instructions, which represent state and behavior to be managed.
All updates happen by assigning to properties, where by subscribers (e.g. components) are notified and refresh automatically.

{/* > Also, it is good to know that Expressive MVC is not mutually exclusive to an existing solution.
> While it can easily meet all of your app's needs, is it easy to migrate or used alongside what you already are.
> It is up to you when and where to replace what works. */}

## MVC Pattern

Like the name suggests, Expressive MVC is based loosely on the [Model-View-Controller](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller) style of development.

In this pattern:

- **Model** - any class (extending `Model` naturally) to define the shape of your state. Think of it like a contract.
- **View** - react component whitch renders the state from one or more models. <br />
  Ideally, these would be stateless components (remember those?) containing nothing but display logic.
- **Controller** - instance of a given Model, managing state for one or more components under the hood.

The key advantages of this architecture:

- **Declerative** - state defined is state managed, state accessed is state subscribed to. <br />
  You do not need to write code to subscribe to state, nor to update it.
- **Typesafe** - models are classes, and can be typed as such. <br />
  You can use typescript to ensure your the model is being used correctly.
- **Scalable** - models can manage just one component or multiple, using context. <br />
  Models can also be composed, allowing you to build complex state separated concerns.
- **Instanced** - models, just like components, are reusable. <br />
  A model can exist in multiple places, but a controller will only affect components assigned to it.

## Models at a glance

To define a model is as simple as extending `Model` and adding some properties.
This can be in either typescript or javascript, but typescript is recommended.

```ts
import Model from "@expressive/react";

class Control extends Model {
  current = 1

  increment = () => { this.current += 1 };
  decrement = () => { this.current -= 1 };
}
```

All models inherit a static property `use` which returns a local instance of that type.
Itself a hook, it will both memoize and refresh for updates which overlap property access of the first render.

```jsx
function Counter(){
  const { current, increment, decrement } = Control.use();

  return (
    <div>
      <button onClick={decrement}>{"-"}</button>
      <pre>{current}</pre>
      <button onClick={increment}>{"+"}</button>
    </div>
  )
}
```

In this example, all properties in the model are accessed, but this doesn't have to be the case.
`Model.use` will intelligently refresh only for properties accessed and ignore others.

## Why use classes?

TBD