import { addListener, scope, watch } from '../observable';
import { access, event, METHOD, State, update } from '../state';
import { Instruction, use } from './use';

const STALE = new WeakSet<() => void>();

declare namespace set {
  type Callback<T, S = any> = (
    this: S,
    next: T,
    previous: T
  ) => ((next: T) => void) | Promise<any> | void | boolean;

  type Compute<T, S = any> = (on: S, key: string) => T;

  type Factory<T, S = any> = (this: S, key: string) => Promise<T> | T;
}

/**
 * Set property as `undefined` but required.
 *
 * Property cannot be accessed until it is defined. If accessed while undefined, a hybrid
 * `Promise`/`Error` (aka: [Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html)) will be thrown.
 */
function set<T = any>(): T;

/**
 * Set property with a factory function.
 *
 * **Note** Factory is lazy! It will only run if/when property is accessed.
 * Value will be undefined until factory resolves, which will also dispatch an update for the property.
 */
function set<T>(factory: set.Factory<T>, required: false): T | undefined;

/**
 * Set property with a factory function.
 *
 * If async, property cannot be accessed until resolves, yeilding a result.
 * If accessed while still processing, React Suspense will be thrown.
 *
 * @param factory - Callback run to derrive property value.
 * @param required - If true run factory immediately on creation, otherwise on access.
 */
function set<T>(factory: set.Factory<T>, required?: boolean): T;

/**
 * Set property with a factory function.
 *
 * If async, property cannot be accessed until resolves, yeilding a result.
 * If accessed while still processing, React Suspense will be thrown.
 *
 * @param factory - Callback run to derrive property value.
 * @param onUpdate - Callback run when property is finished computing or is set.
 */
function set<T>(factory: set.Factory<T>, onUpdate?: set.Callback<T>): T;

/**
 * Set a property with empty placeholder and/or update callback.
 *
 * @param value - Starting value for property. If undefined, suspense will be thrown on access, until value is set and accepted by callback.
 * @param onUpdate - Callback run when property is set. If returns false, update is not accepted and property will keep previous value.
 */
function set<T>(value: T | undefined, onUpdate?: set.Callback<T>): T;

/**
 * Implement a reactive computed value using a method reference.
 *
 * The method will automatically re-run when any accessed properties change.
 * Use `true` to indicate reactive mode with implicit `this` as the source.
 *
 * @param reactiveToThis - Pass `true` to enable reactive mode with implicit this
 * @param method - Method reference or compute function to use
 */
function set<R, T = any>(
  reactiveToThis: true,
  method: set.Compute<R, T> | Function
): R;

/**
 * Implement a computed value; output will be generated by provided function.
 *
 * @param reactiveTo - Source state from which computed value will be a subscriber.
 * @param compute - Compute function. Bound to a subscriber-proxy of source, returns output value. Will update automatically as input values change.
 */
function set<R, T extends State>(reactiveTo: T, compute: set.Compute<R, T>): R;

function set<T = any>(value?: unknown, argument?: unknown): any {
  return use<T>((key, subject, state) => {
    if (typeof value == 'symbol')
      throw new Error(
        `Attempted to use an instruction result (probably use or get) as computed source for ${subject}.${key}. This is not allowed.`
      );

    const property: Instruction.Descriptor = {};

    // Handle reactive compute modes
    if (value instanceof State || value === true) {
      let from = subject;
      let getter: set.Compute<T, any>;

      if (value instanceof State) {
        from = value;
        getter = argument as set.Compute<T, any>;
      } else {
        // value === true, implicit this with method reference
        const fn = METHOD.get(argument) || argument;
        getter = ((p, k) => fn.call(p, k, p)) as set.Compute<T, any>;
      }

      type Source<T extends State = State> = (resolve: (x: T) => void) => void;
      const source: Source = (resolve) => resolve(from);

      let reset: (() => void) | undefined;
      let isAsync: boolean;
      let proxy: any;

      function connect(self: State) {
        reset = watch(
          self,
          (current) => {
            proxy = current;

            if (!(key in state) || STALE.delete(compute)) compute(!reset);

            return (didUpdate) => {
              if (didUpdate) {
                STALE.add(compute);
                event(subject, key, true);
              }
            };
          },
          false
        );
      }

      function compute(initial?: boolean) {
        let next: T | undefined;

        try {
          next = getter.call(proxy, proxy, key);
        } catch (err) {
          console.warn(
            `An exception was thrown while ${
              initial ? 'initializing' : 'refreshing'
            } ${subject}.${key}.`
          );

          if (initial) throw err;

          console.error(err);
        }

        update(subject, key, next, !isAsync);
      }

      return () => {
        if (!proxy) {
          source(connect);
          isAsync = true;
        }

        if (STALE.delete(compute)) compute();

        return access(subject, key, !proxy) as T;
      };
    }

    // Handle factory/value modes (existing logic)
    if (typeof value == 'function' || value instanceof Promise) {
      function init() {
        if (typeof value == 'function')
          try {
            value = attempt(value.bind(subject, key));
          } catch (err) {
            console.warn(
              `Generating initial value for ${subject}.${key} failed.`
            );
            throw err;
          }

        property.get = argument !== false;

        const set = (value: any) => (subject[key] = value);

        if (value instanceof Promise)
          value.then(set, (error) => {
            event(subject, key);
            property.get = () => {
              throw error;
            };
          });
        else set(value);

        if (argument) return null;

        return subject[key];
      }

      if (argument) {
        addListener(subject, init, true);
      } else {
        property.get = init;
      }
    } else if (value !== undefined) {
      property.value = value;
    }

    if (typeof argument == 'function') {
      let unset: ((next: T) => void) | undefined;

      property.set = function (this: any, value: any, previous: any) {
        const exit = scope();
        const returns = argument.call(this, value, previous);
        const flush = exit();

        if (returns === false) return false;

        if (typeof unset == 'function') unset(value);

        unset = (next: T) => {
          if (typeof returns == 'function') returns(next);

          flush();
        };
      };
    } else
      property.set = (value) => {
        property.get = undefined;
        update(subject, key, value);
      };

    return property;
  });
}

function attempt(fn: () => any): any {
  // Ignore TS80006: Function must be synchronous.
  function retry(err: unknown) {
    if (err instanceof Promise) return err.then(compute);
    else throw err;
  }

  function compute(): any {
    try {
      const output = fn();

      return output instanceof Promise ? output.catch(retry) : output;
    } catch (err) {
      return retry(err);
    }
  }

  return compute();
}

export { set };
