import { Context } from '../context';
import { State, PARENT, update } from '../state';
import { use } from './use';

type Type<T extends State> = State.Extends<T> & typeof State;

declare namespace get {
  type Effect<T> = (state: T, key: string) => (() => void) | void;
}

/**
 * Fetches and assigns the controller which spawned this host.
 * When parent assigns an instance via `use()` directive, it
 * will be made available to child upon this request.
 *
 * @param Type - Type of controller compatible with this class.
 * @param expectParent - If true, will throw if State is created without a parent.
 */
function get<T extends State>(Type: State.Extends<T>, expectParent?: true): T;

/**
 * Fetches and assigns the controller which spawned this host.
 * When parent assigns an instance via `use()` directive, it
 * will be made available to child upon this request.
 *
 * @param Type - Type of controller compatible with this class.
 * @param required - If false, property may be undefined. Otherwise will throw suspense.
 */
function get<T extends State>(
  Type: State.Extends<T>,
  required?: false
): T | undefined;

/**
 * Implement a computed value from a foreign state. Output will be generated by provided function,
 * where the foreign state will be passed to that function.
 *
 * @param source - Type of State to fetch for computation.
 * @param compute - Compute function. Will update automatically as input values change.
 */
function get<T extends State>(Type: State.Extends<T>, effect: get.Effect<T>): T;

function get<R, T extends State>(arg0: Type<T>, arg1?: Function | boolean) {
  return use((key, subject) => {
    const hasParent = PARENT.get(subject) as T;

    // TODO: notify on discovered context
    function assign(value: T) {
      if (typeof arg1 == 'function')
        value.get((x) => (arg1 as Function)(x, key));

      update(subject, key, value);
    }

    if (!hasParent && arg1 === true)
      throw new Error(`${subject} may only exist as a child of type ${arg0}.`);
    else if (hasParent)
      if (hasParent instanceof arg0) {
        assign(hasParent);
        return {};
      } else if (arg1 === true)
        throw new Error(
          `New ${subject} created as child of ${hasParent}, but must be instanceof ${arg0}.`
        );

    Context.get(subject, (context) => {
      const self = context.get(arg0);

      if (self) assign(self);
      else if (arg1 !== false)
        throw new Error(
          `Required ${arg0} not found in context for ${subject}.`
        );
    });

    return {
      get: arg1 !== false,
      enumerable: false
    };
  });
}

export { get };
